---
import ProjectLayout from '../../layouts/ProjectLayout.astro';

const frontmatter = {
  title: "POS System (Carwash/Restaurant)",
  description: "A comprehensive browser-based Point-of-Sale system serving multiple businesses with real-time order management, payment processing, and receipt printing.",
  technologies: ["React", "Node.js", "PostgreSQL", "Socket.io", "Docker", "Express", "Redis"],
  outcome: "Streamlined operations for 3 businesses, reducing transaction time by 60%",
  timeline: "4 months",
  role: "Full-Stack Developer & System Architect",
  repoUrl: "https://github.com/solvin-it/pos-system",
  liveUrl: null,
};
---

<ProjectLayout {...frontmatter}>

## Overview

This Point-of-Sale (POS) system transformed operations for three local businesses: two restaurants and a carwash service. Built as a comprehensive browser-based solution, it handles everything from order taking and payment processing to inventory management and real-time reporting, all while being intuitive enough for busy service environments.

## The Business Challenge

The businesses were struggling with:
- **Manual order tracking** leading to errors and delays
- **Inconsistent pricing** across different staff members
- **No centralized reporting** for sales and inventory
- **Cash register limitations** that couldn't handle complex orders
- **Inefficient workflows** during peak hours
- **Receipt printing issues** with various hardware setups

They needed a unified system that could:
- Handle high-volume transactions quickly
- Work reliably in demanding service environments
- Provide real-time business insights
- Scale across multiple business types
- Integrate with existing hardware (printers, payment terminals)

## System Architecture

### Frontend: React-Based POS Interface

```typescript
// Core POS interface component
const POSInterface: React.FC = () => {
  const [currentOrder, setCurrentOrder] = useState<Order>();
  const [products, setProducts] = useState<Product[]>([]);
  const [activeTable, setActiveTable] = useState<Table | null>();

  return (
    <div className="pos-layout">
      <ProductGrid 
        products={products}
        onProductSelect={addToOrder}
        categories={categories}
      />
      
      <OrderSummary 
        order={currentOrder}
        onModifyItem={modifyOrderItem}
        onRemoveItem={removeOrderItem}
      />
      
      <PaymentPanel
        total={currentOrder?.total}
        onPaymentProcess={handlePayment}
        supportedMethods={['cash', 'card', 'mobile']}
      />
    </div>
  );
};
```

### Backend: Node.js + PostgreSQL

```javascript
// Order processing API
app.post('/api/orders', async (req, res) => {
  const { items, customerId, tableId, paymentMethod } = req.body;
  
  try {
    // Start transaction
    await db.beginTransaction();
    
    // Create order record
    const order = await db.orders.create({
      customer_id: customerId,
      table_id: tableId,
      status: 'pending',
      total: calculateTotal(items),
      created_at: new Date()
    });
    
    // Add order items
    for (const item of items) {
      await db.order_items.create({
        order_id: order.id,
        product_id: item.productId,
        quantity: item.quantity,
        price: item.price,
        modifications: item.modifications
      });
      
      // Update inventory
      await updateInventory(item.productId, -item.quantity);
    }
    
    // Process payment
    const payment = await processPayment({
      amount: order.total,
      method: paymentMethod,
      order_id: order.id
    });
    
    await db.commitTransaction();
    
    // Emit real-time update
    io.emit('order_created', { order, items });
    
    // Queue receipt printing
    await printQueue.add('receipt', {
      orderId: order.id,
      businessId: req.user.businessId
    });
    
    res.json({ success: true, orderId: order.id });
    
  } catch (error) {
    await db.rollbackTransaction();
    res.status(500).json({ error: error.message });
  }
});
```

### Real-Time Updates: Socket.io

```javascript
// Real-time order tracking
io.on('connection', (socket) => {
  socket.on('join_business', (businessId) => {
    socket.join(`business_${businessId}`);
  });
  
  // Kitchen display updates
  socket.on('order_ready', async (orderId) => {
    const order = await db.orders.findById(orderId);
    
    // Update order status
    await db.orders.update(orderId, { status: 'ready' });
    
    // Notify front-of-house
    io.to(`business_${order.business_id}`).emit('order_status_change', {
      orderId,
      status: 'ready',
      timestamp: new Date()
    });
  });
});
```

## Multi-Business Configuration

### Business-Specific Customization

```typescript
// Business configuration system
interface BusinessConfig {
  id: string;
  name: string;
  type: 'restaurant' | 'carwash' | 'retail';
  settings: {
    taxRate: number;
    currency: string;
    receiptTemplate: string;
    paymentMethods: PaymentMethod[];
    features: FeatureSet;
  };
  branding: {
    logo: string;
    colors: ColorScheme;
    fonts: FontSet;
  };
}

// Restaurant-specific features
const restaurantFeatures = {
  tableManagement: true,
  kitchenDisplay: true,
  orderModifications: true,
  splitBills: true,
  tipCalculation: true
};

// Carwash-specific features  
const carwashFeatures = {
  servicePackages: true,
  vehicleTracking: true,
  queueManagement: true,
  loyaltyProgram: true,
  timeSlotBooking: true
};
```

### Multi-Tenant Data Architecture

```sql
-- Core business separation
CREATE TABLE businesses (
    id UUID PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    type business_type NOT NULL,
    settings JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Tenant-specific product catalog
CREATE TABLE products (
    id UUID PRIMARY KEY,
    business_id UUID REFERENCES businesses(id),
    name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    category_id UUID,
    is_active BOOLEAN DEFAULT true,
    inventory_tracked BOOLEAN DEFAULT false,
    current_stock INTEGER DEFAULT 0
);

-- Orders with business context
CREATE TABLE orders (
    id UUID PRIMARY KEY,
    business_id UUID REFERENCES businesses(id),
    table_id UUID,
    customer_id UUID,
    total DECIMAL(10,2) NOT NULL,
    tax_amount DECIMAL(10,2),
    status order_status DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);
```

## Payment Processing Integration

### Multi-Payment Method Support

```typescript
// Payment processing abstraction
class PaymentProcessor {
  private processors: Map<PaymentMethod, PaymentProvider> = new Map();
  
  constructor() {
    this.processors.set('card', new StripeProcessor());
    this.processors.set('cash', new CashProcessor());
    this.processors.set('mobile', new MobilePayProcessor());
  }
  
  async processPayment(payment: PaymentRequest): Promise<PaymentResult> {
    const processor = this.processors.get(payment.method);
    
    if (!processor) {
      throw new Error(`Unsupported payment method: ${payment.method}`);
    }
    
    try {
      const result = await processor.charge({
        amount: payment.amount,
        currency: payment.currency,
        metadata: {
          orderId: payment.orderId,
          businessId: payment.businessId
        }
      });
      
      // Record transaction
      await this.recordTransaction(payment, result);
      
      return result;
      
    } catch (error) {
      await this.logPaymentError(payment, error);
      throw new PaymentProcessingError(error.message);
    }
  }
}
```

### Receipt Generation & Printing

```typescript
// Dynamic receipt template system
class ReceiptGenerator {
  generateReceipt(order: Order, business: Business): ReceiptData {
    const template = this.getTemplate(business.type);
    
    return {
      header: this.buildHeader(business),
      items: this.buildItemList(order.items),
      totals: this.buildTotalsSection(order),
      footer: this.buildFooter(business),
      formatting: template.formatting
    };
  }
  
  private buildItemList(items: OrderItem[]): ReceiptItem[] {
    return items.map(item => ({
      name: item.product.name,
      quantity: item.quantity,
      price: item.price,
      total: item.quantity * item.price,
      modifications: item.modifications?.join(', ') || ''
    }));
  }
}

// Print queue management
class PrintManager {
  private queue: Queue = new Queue('print-jobs', {
    redis: { host: 'localhost', port: 6379 }
  });
  
  async queueReceipt(orderId: string, businessId: string) {
    return this.queue.add('receipt', {
      orderId,
      businessId,
      priority: 'high',
      attempts: 3,
      backoff: 'exponential'
    });
  }
  
  processJob(job: Job) {
    const { orderId, businessId } = job.data;
    
    // Generate receipt
    const receipt = this.receiptGenerator.generateReceipt(orderId);
    
    // Send to appropriate printer
    return this.printToDevice(receipt, businessId);
  }
}
```

## Kitchen Display System

For restaurant businesses, I implemented a real-time kitchen display:

```typescript
// Kitchen display component
const KitchenDisplay: React.FC = () => {
  const [pendingOrders, setPendingOrders] = useState<Order[]>([]);
  const [inProgressOrders, setInProgressOrders] = useState<Order[]>([]);
  
  useEffect(() => {
    // Real-time order updates
    socket.on('new_order', (order) => {
      setPendingOrders(prev => [...prev, order]);
    });
    
    socket.on('order_started', (orderId) => {
      setPendingOrders(prev => prev.filter(o => o.id !== orderId));
      // Move to in-progress...
    });
  }, []);
  
  return (
    <div className="kitchen-display">
      <OrderColumn
        title="New Orders"
        orders={pendingOrders}
        onOrderStart={startOrder}
        color="red"
      />
      
      <OrderColumn
        title="In Progress"
        orders={inProgressOrders}
        onOrderComplete={completeOrder}
        color="yellow"
      />
      
      <OrderColumn
        title="Ready"
        orders={readyOrders}
        onOrderServed={serveOrder}
        color="green"
      />
    </div>
  );
};
```

## Inventory Management

```typescript
// Automated inventory tracking
class InventoryManager {
  async updateStock(productId: string, quantityChange: number, reason: string) {
    await db.beginTransaction();
    
    try {
      // Update current stock
      const product = await db.products.findById(productId);
      const newStock = product.current_stock + quantityChange;
      
      if (newStock < 0 && reason === 'sale') {
        throw new Error('Insufficient inventory');
      }
      
      await db.products.update(productId, {
        current_stock: newStock,
        last_updated: new Date()
      });
      
      // Log inventory movement
      await db.inventory_movements.create({
        product_id: productId,
        quantity_change: quantityChange,
        reason,
        new_balance: newStock,
        timestamp: new Date()
      });
      
      // Check low stock alerts
      if (newStock <= product.low_stock_threshold) {
        await this.sendLowStockAlert(product);
      }
      
      await db.commitTransaction();
      
    } catch (error) {
      await db.rollbackTransaction();
      throw error;
    }
  }
  
  async generateInventoryReport(businessId: string, dateRange: DateRange) {
    return await db.query(`
      SELECT 
        p.name,
        p.current_stock,
        COALESCE(SUM(CASE WHEN im.reason = 'sale' THEN ABS(im.quantity_change) ELSE 0 END), 0) as total_sold,
        COALESCE(SUM(CASE WHEN im.reason = 'restock' THEN im.quantity_change ELSE 0 END), 0) as total_restocked
      FROM products p
      LEFT JOIN inventory_movements im ON p.id = im.product_id 
        AND im.timestamp >= $2 AND im.timestamp <= $3
      WHERE p.business_id = $1
      GROUP BY p.id, p.name, p.current_stock
      ORDER BY total_sold DESC
    `, [businessId, dateRange.start, dateRange.end]);
  }
}
```

## Performance Optimizations

### Database Performance
- **Indexed queries** for fast order lookup and reporting
- **Connection pooling** for handling concurrent users
- **Read replicas** for reporting without impacting transactions
- **Prepared statements** for security and performance

### Caching Strategy
```typescript
// Redis caching for frequently accessed data
class CacheManager {
  private redis = new Redis(process.env.REDIS_URL);
  
  async getProducts(businessId: string): Promise<Product[]> {
    const cacheKey = `products:${businessId}`;
    
    // Try cache first
    const cached = await this.redis.get(cacheKey);
    if (cached) {
      return JSON.parse(cached);
    }
    
    // Fetch from database
    const products = await db.products.findByBusiness(businessId);
    
    // Cache for 1 hour
    await this.redis.setex(cacheKey, 3600, JSON.stringify(products));
    
    return products;
  }
  
  async invalidateBusinessCache(businessId: string) {
    const pattern = `*:${businessId}`;
    const keys = await this.redis.keys(pattern);
    
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}
```

## Results & Business Impact

### Operational Improvements
- **Transaction time reduction**: 60% faster order processing
- **Order accuracy**: 95% improvement in order correctness
- **Staff productivity**: 40% increase in orders handled per hour
- **Customer satisfaction**: Reduced wait times and improved service quality

### Financial Impact
- **Revenue tracking**: Real-time sales reporting and analytics
- **Cost reduction**: Eliminated need for multiple point solutions
- **Inventory optimization**: 25% reduction in food waste through better tracking
- **Labor efficiency**: Reduced need for manual cash reconciliation

### Technical Performance
- **Uptime**: 99.8% availability across all locations
- **Response time**: Sub-200ms average API response times
- **Concurrent users**: Successfully handling 50+ simultaneous users per location
- **Data integrity**: Zero data loss incidents over 18-month operation period

## Challenges & Solutions

### Challenge: Hardware Integration
**Problem**: Each business had different receipt printers and payment terminals.
**Solution**: Built abstraction layer with driver support for multiple printer protocols (ESC/POS, Star, etc.) and payment gateway adapters.

### Challenge: Internet Reliability
**Problem**: Service interruptions couldn't stop business operations.
**Solution**: Implemented offline mode with local SQLite cache that syncs when connectivity returns.

### Challenge: Staff Training
**Problem**: Varying technical comfort levels among staff members.
**Solution**: Created role-based interfaces with progressive complexity and built-in help system with contextual guidance.

### Challenge: Multi-Business Scalability
**Problem**: Each business had unique workflows and requirements.
**Solution**: Developed configurable business logic engine with per-tenant customization capabilities.

## Key Technical Learnings

### Real-World System Design
1. **Resilience first**: Building for failure scenarios is more important than perfect-case performance
2. **User experience matters**: Technical elegance means nothing if staff can't use the system effectively
3. **Data integrity is critical**: Financial systems require bulletproof transaction handling

### Business Application Development
1. **Domain expertise is essential**: Understanding business operations deeply influenced technical decisions
2. **Flexibility vs. simplicity**: Finding the balance between configurability and usability
3. **Performance under pressure**: Systems must work reliably during peak business hours

### Multi-Tenancy Best Practices
1. **Data isolation**: Proper tenant separation prevents cross-business data leaks
2. **Configuration management**: Centralized config with business-specific overrides
3. **Monitoring and alerting**: Per-tenant metrics and health monitoring

## Future Enhancements

### Planned Features
- **Mobile ordering integration** for customer self-service
- **Advanced analytics** with predictive insights
- **Loyalty program management** across all business types
- **Supply chain integration** for automated ordering

### Technical Improvements
- **Microservices architecture** for better scalability
- **Event sourcing** for complete audit trails
- **Machine learning** for demand forecasting
- **Mobile app** for business owners to monitor remotely

This project demonstrated the value of well-designed systems thinking in solving real business problems. The success across three different business types validated the architectural decisions and showed how technology can genuinely transform small business operations.

</ProjectLayout>